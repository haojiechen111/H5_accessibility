====================================================================
Android WebView Accessibility 平滑滚动方案 - 使用指南
====================================================================

【问题描述】
当使用语音助手（如"向下滑动"、"向上滑动"）控制WebView滚动时，页面会瞬间跳转到新位置，
没有平滑的滚动动画，用户体验很差。

【原因分析】
Android系统的Accessibility服务在控制WebView滚动时，直接调用底层native代码，
导致页面瞬间跳转，无法被Java层拦截。

【解决方案】
通过监听WebView的onScrollChanged回调，检测到大幅度瞬间滚动时，先回滚到原位置，
然后使用JavaScript动画实现300ms的平滑滚动效果。

====================================================================
实现步骤（超详细版）
====================================================================

步骤1：创建自定义WebView类
---------------------------------
在你的项目中创建一个新的Java类，继承自WebView。

文件路径示例：app/src/main/java/com/your/package/CustomWebView.java

完整代码如下（直接复制粘贴）：

```java
package com.your.package;  // 改成你的包名

import android.animation.ValueAnimator;
import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.animation.DecelerateInterpolator;
import android.webkit.WebView;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.View;

public class CustomWebView extends WebView {

    private static final String TAG = "CustomWebView";
    private static final int SCROLL_DURATION = 300; // 滚动动画持续时间(毫秒)
    private int lastScrollY = 0;
    private long lastScrollTime = 0;
    private boolean isInSmoothScroll = false;

    // 三个构造方法必须都要有
    public CustomWebView(Context context) {
        super(context);
    }

    public CustomWebView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public CustomWebView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    /**
     * 监听滚动变化 - 这是核心方法
     */
    @Override
    protected void onScrollChanged(int l, int t, int oldl, int oldt) {
        super.onScrollChanged(l, t, oldl, oldt);
        
        int distance = Math.abs(t - oldt);
        
        Log.d(TAG, "onScrollChanged: new=" + t + ", old=" + oldt + ", distance=" + distance);
        
        long currentTime = System.currentTimeMillis();
        long timeDiff = currentTime - lastScrollTime;
        
        // 检测accessibility瞬间滚动的特征：
        // 1. 滚动距离大于100px
        // 2. 距离上次滚动时间超过100ms（说明不是连续手动滑动）
        // 3. 不在平滑滚动过程中
        if (distance > 100 && timeDiff > 100 && !isInSmoothScroll) {
            Log.d(TAG, "检测到accessibility大幅瞬间滚动，启用平滑动画");
            
            // 先更新时间戳和标志位，避免回滚触发的onScrollChanged被误判
            lastScrollTime = currentTime;
            isInSmoothScroll = true;
            
            // 直接回滚到旧位置并立即执行平滑滚动
            CustomWebView.super.scrollTo(0, oldt);
            smoothScrollToWithJS(t);
            
            // 300ms后重置标志
            postDelayed(new Runnable() {
                @Override
                public void run() {
                    isInSmoothScroll = false;
                }
            }, 350);
            
            lastScrollY = t;
            return; // 提前返回，避免重复更新
        }
        
        lastScrollY = t;
        lastScrollTime = currentTime;
    }

    /**
     * 使用JavaScript实现平滑滚动
     */
    private void smoothScrollToWithJS(int targetY) {
        int startY = getScrollY();  // 获取当前位置作为起点
        String js = String.format(
            "(function() {" +
            "  console.log('Java调用JS平滑滚动, 起点:', %d, '目标:', %d);" +
            "  var start = %d;" +  // 直接使用Java传入的起点，不读取
            "  var target = %d;" +
            "  var distance = target - start;" +
            "  var duration = 300;" +
            "  var startTime = performance.now();" +
            "  " +
            "  console.log('动画参数: start=' + start + ', target=' + target + ', distance=' + distance);" +
            "  " +
            "  if (distance === 0) {" +
            "    console.log('距离为0，跳过动画');" +
            "    return;" +
            "  }" +
            "  " +
            "  function animate(currentTime) {" +
            "    var elapsed = currentTime - startTime;" +
            "    var progress = Math.min(elapsed / duration, 1);" +
            "    var easeProgress = Math.sin((progress * Math.PI) / 2);" +
            "    var newScroll = start + distance * easeProgress;" +
            "    " +
            "    window.scrollTo(0, newScroll);" +
            "    console.log('动画进度:', (progress * 100).toFixed(0) + '%%', 'scrollY:', Math.round(newScroll));" +
            "    " +
            "    if (progress < 1) {" +
            "      requestAnimationFrame(animate);" +
            "    } else {" +
            "      console.log('动画完成');" +
            "    }" +
            "  }" +
            "  " +
            "  requestAnimationFrame(animate);" +
            "})();",
            startY, targetY, startY, targetY
        );
        
        Log.d(TAG, "执行JS平滑滚动");
        evaluateJavascript(js, null);
    }
}
```

步骤2：修改布局文件
---------------------------------
将原来的 <WebView> 标签改成 <com.your.package.CustomWebView>

示例：
原来的布局文件（activity_main.xml）：

```xml
<WebView
    android:id="@+id/webView"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

修改后：

```xml
<com.your.package.CustomWebView
    android:id="@+id/webView"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scrollbars="vertical" />
```

注意：
1. 把 com.your.package 改成你的实际包名
2. 必须使用完整的类名路径（包名+类名）
3. 建议加上 android:scrollbars="vertical" 让系统知道这是可滚动的

步骤3：修改Activity代码
---------------------------------
在Activity中使用CustomWebView替代原来的WebView

示例：

```java
// 原来的代码
WebView webView = findViewById(R.id.webView);

// 修改后的代码
CustomWebView webView = findViewById(R.id.webView);

// 其他代码保持不变
webView.getSettings().setJavaScriptEnabled(true);
webView.loadUrl("file:///android_asset/index.html");
```

步骤4：测试
---------------------------------
1. 构建并运行应用
2. 确保WebView页面内容足够长，可以滚动
3. 使用语音命令："向下滑动" 或 "向上滑动"
4. 观察效果：应该能看到300ms的平滑滚动动画

====================================================================
完整示例项目结构
====================================================================

your-project/
├── app/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/
│   │   │   │   └── com/
│   │   │   │       └── your/
│   │   │   │           └── package/
│   │   │   │               ├── MainActivity.java
│   │   │   │               └── CustomWebView.java  ← 新建这个文件
│   │   │   ├── res/
│   │   │   │   └── layout/
│   │   │   │       └── activity_main.xml  ← 修改WebView标签
│   │   │   └── assets/
│   │   │       └── index.html  ← 你的H5页面

====================================================================
常见问题排查
====================================================================

问题1：没有平滑滚动效果
解决：
1. 检查Logcat日志，搜索"CustomWebView"标签
2. 应该能看到"onScrollChanged"和"检测到accessibility大幅瞬间滚动"的日志
3. 如果没有日志，说明没有使用CustomWebView，检查步骤2和步骤3

问题2：编译错误，找不到CustomWebView
解决：
1. 确认CustomWebView.java的包名是否正确
2. 确认布局文件中的完整类名路径是否正确
3. Clean Project后重新构建

问题3：WebView显示空白
解决：
1. 确认JavaScript已启用：webView.getSettings().setJavaScriptEnabled(true)
2. 检查H5页面路径是否正确
3. 查看Logcat是否有错误信息

问题4：有时候有动画，有时候没有
解决：
这是正常的，只有accessibility触发的大幅度瞬间滚动才会触发平滑动画。
手动滑动不会触发，因为时间差判断会排除连续滚动。

问题5：手动快速滑动感觉卡顿
解决：
可以调整时间差阈值，在CustomWebView.java中修改：
将 if (distance > 100 && timeDiff > 100 && !isInSmoothScroll)
改成 if (distance > 100 && timeDiff > 200 && !isInSmoothScroll)  // 提高时间阈值

====================================================================
高级配置（可选）
====================================================================

1. 调整动画时长
在CustomWebView.java中修改：
private static final int SCROLL_DURATION = 300;  // 改成你想要的毫秒数

2. 调整检测阈值
在onScrollChanged方法中修改：
if (distance > 100 && timeDiff > 100 && !isInSmoothScroll)
// distance > 100: 滚动距离阈值，可以改成50、150等
// timeDiff > 100: 时间间隔阈值（毫秒），避免误判手动滑动，可以改成50、200等

3. 修改动画曲线
在smoothScrollToWithJS方法中修改：
var easeProgress = Math.sin((progress * Math.PI) / 2);  // 正弦缓动（默认）
// 可以改成：
var easeProgress = progress;  // 线性
var easeProgress = 1 - Math.pow(1 - progress, 3);  // 三次缓动

====================================================================
原理说明（给想了解的人看）
====================================================================

1. 为什么不能直接拦截滚动？
   - WebView使用Chromium内核，accessibility操作在native层执行
   - 无法通过重写performAccessibilityAction()方法拦截
   - 也无法通过重写scrollTo()方法拦截

2. 为什么使用onScrollChanged？
   - 这是View的回调方法，所有滚动都会触发
   - 可以检测到accessibility触发的瞬间跳转
   - 通过时间差判断区分手动滑动和accessibility滚动

3. 为什么要回滚再滚动？
   - 因为accessibility已经完成了瞬间跳转
   - 我们需要"撤销"这个跳转
   - 然后用JavaScript重新执行一次平滑滚动

4. 为什么用JavaScript而不是Java动画？
   - Java层的scrollTo会再次触发onScrollChanged，容易死循环
   - JavaScript的window.scrollTo在H5页面内执行，更流畅
   - 使用requestAnimationFrame可以与浏览器渲染同步

5. 为什么直接在Java中获取起点而不是在JS中读取？
   - 回滚和JS执行几乎同时发生
   - JS读取scrollY可能在回滚完成前执行，获取到错误的值
   - 导致起点等于目标，distance为0，没有动画
   - 在Java中回滚后立即获取位置更可靠

====================================================================
版本历史
====================================================================

v1.0 (2025-12-26)
- 初始版本
- 实现基于onScrollChanged的平滑滚动检测
- 使用JavaScript requestAnimationFrame实现动画
- 300ms正弦缓动曲线（easeInSine）

v1.1 (2025-12-26)
- 修复手动快速滑动卡顿问题
- 添加时间差判断（100ms阈值）区分手动滑动和accessibility滚动
- 手动滑动不再触发平滑动画，保持原生流畅体验

v1.2 (2025-12-26)
- 优化动画启动流程，移除所有延迟
- 回滚和平滑滚动同步执行，消除停顿感
- 动画启动更加流畅即时

v1.3 (2025-12-26)
- 修复回滚操作导致的onScrollChanged重复触发问题
- 优化时间戳更新顺序，避免回滚被误判为新的滚动
- 添加提前返回逻辑，防止变量重复更新
- 彻底解决回滚引起的视觉闪烁和循环问题

v1.4 (2025-12-26)
- 修复JS动画参数传递问题
- 在Java中获取起始位置，直接传入JS，不依赖JS读取scrollY
- 添加距离验证，避免distance为0时执行无效动画
- 增强调试日志输出（起点、目标、动画参数、进度等）
- 提高动画执行的可靠性和可调试性

====================================================================
联系方式
====================================================================

如有问题，请提供：
1. 完整的错误日志（Logcat）
2. CustomWebView.java的代码
3. 布局文件XML
4. 简要描述问题现象

====================================================================
